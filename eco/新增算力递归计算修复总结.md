# 新增算力递归计算修复总结

## 📊 **修复前的问题**

### **原有错误逻辑**
- 新增算力只计算当前用户自己今天新增的矿机算力
- 没有递归计算子级今天新增的算力
- 不符合业务需求，应该像小区算力一样递归计算

### **错误代码示例**
```java
// 修复前 - 只计算自己的新增算力
LambdaQueryWrapper<PurchaseMinerProject> queryWrapper = new LambdaQueryWrapper<>();
queryWrapper.eq(PurchaseMinerProject::getWalletAddress, walletAddress);
// ... 只查询当前用户的矿机
```

## 🔧 **修复后的正确逻辑**

### **新的计算方式**
1. **递归计算**：计算自己和所有子级今天新增的算力
2. **阶梯计算**：应用层级费率规则
3. **缓存机制**：避免重复计算，提高性能

### **核心方法**

#### 1. `calculateUserNewPower` - 主入口方法
```java
@Override
public SingleResponse<BigDecimal> calculateUserNewPower(String walletAddress, String dayTime, 
                                                       Map<Integer, BigDecimal> levelRateMap, Boolean isLevel) {
    // 获取用户层级信息
    Integer userLevel = getUserLevel(walletAddress);
    
    // 递归计算新增算力 - 包括自己和所有子级今天新增的算力
    Map<String, BigDecimal> computedPowerMap = new HashMap<>();
    BigDecimal totalNewPower = calculateNewPowerWithLevel(
        userLevel, walletAddress, dayTime, levelRateMap, computedPowerMap, isLevel
    );
    
    return SingleResponse.of(totalNewPower);
}
```

#### 2. `calculateNewPowerWithLevel` - 递归计算方法
```java
private BigDecimal calculateNewPowerWithLevel(Integer parentLevel, String walletAddress, String dayTime, 
                                             Map<Integer, BigDecimal> levelRateMap, 
                                             Map<String, BigDecimal> cache, Boolean isLevel) {
    // 1. 计算当前用户今天新增的算力
    BigDecimal currentNewPower = calculateUserSelfNewPower(walletAddress, dayTime);
    
    // 2. 查询直接下级
    List<Recommend> directSubordinates = getDirectSubordinates(walletAddress);
    
    // 3. 递归计算每个下级的新增算力
    BigDecimal subordinateNewPower = BigDecimal.ZERO;
    for (Recommend subordinate : directSubordinates) {
        BigDecimal subNewPower = calculateNewPowerWithLevel(/* 递归调用 */);
        
        // 4. 应用阶梯计算
        if (isLevel && levelRateMap != null) {
            Integer relativeLevel = subordinateLevel - parentLevel;
            BigDecimal levelRate = levelRateMap.get(relativeLevel);
            if (levelRate != null && levelRate.compareTo(BigDecimal.ZERO) > 0) {
                subNewPower = subNewPower.multiply(levelRate);
            }
        }
        
        subordinateNewPower = subordinateNewPower.add(subNewPower);
    }
    
    // 5. 总新增算力 = 自身新增算力 + 下级新增算力
    return currentNewPower.add(subordinateNewPower);
}
```

#### 3. `calculateUserSelfNewPower` - 计算自身新增算力
```java
private BigDecimal calculateUserSelfNewPower(String walletAddress, String dayTime) {
    // 查询当日新增的矿机
    long startTime = getDayStartTime(dayTime);
    long endTime = getDayEndTime(dayTime);
    
    List<PurchaseMinerProject> newMiners = queryNewMiners(walletAddress, startTime, endTime);
    
    // 计算自身新增算力
    return newMiners.stream()
            .map(miner -> new BigDecimal(miner.getActualComputingPower()))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
}
```

## 📊 **算力层级结构示例**

```
用户A (3级)
├── 自身今天新增算力: 100
├── 直推B (4级) 今天新增算力: 200
│   ├── B的子级1 (5级) 今天新增算力: 150
│   └── B的子级2 (5级) 今天新增算力: 300
└── 直推C (4级) 今天新增算力: 180
    └── C的子级1 (5级) 今天新增算力: 120

计算过程：
1. A自身新增算力: 100
2. B及其子级新增算力: 200 + (150 + 300) = 650
   - 应用阶梯计算: 650 * levelRate[4-3] = 650 * 0.8 = 520
3. C及其子级新增算力: 180 + 120 = 300
   - 应用阶梯计算: 300 * levelRate[4-3] = 300 * 0.8 = 240
4. A的总新增算力: 100 + 520 + 240 = 860
```

## 🔄 **与小区算力的对比**

| 特性 | 小区算力 | 新增算力 |
|------|----------|----------|
| **计算范围** | 所有子级的总算力 | 所有子级今天新增的算力 |
| **递归方式** | 递归计算总算力 | 递归计算新增算力 |
| **阶梯计算** | 支持 | 支持 |
| **缓存机制** | 支持 | 支持 |
| **计算逻辑** | 自身算力 + 子级算力 | 自身新增算力 + 子级新增算力 |

## ✅ **修复验证**

### **修复前**
- ❌ 只计算自己的新增算力
- ❌ 没有递归计算子级
- ❌ 不符合业务需求

### **修复后**
- ✅ 递归计算自己和所有子级的新增算力
- ✅ 支持阶梯计算规则
- ✅ 使用缓存机制提高性能
- ✅ 与小区算力计算逻辑保持一致

## 🚀 **使用方式**

```java
// 获取层级费率映射
Map<Integer, BigDecimal> levelRateMap = getLevelRateMap();

// 计算新增算力（递归阶梯计算）
SingleResponse<BigDecimal> newPowerResponse = computingPowerService.calculateUserNewPower(
    walletAddress, 
    dayTime, 
    levelRateMap, 
    true  // 启用阶梯计算
);
```

## 📝 **注意事项**

1. **层级差计算**：`relativeLevel = subordinateLevel - parentLevel`
2. **阶梯费率**：根据层级差从 `levelRateMap` 获取对应费率
3. **缓存机制**：避免重复计算，提高性能
4. **异常处理**：计算失败时返回 `BigDecimal.ZERO`
5. **日志记录**：记录计算过程和结果，便于调试

修复完成！新增算力现在可以正确递归计算所有子级今天新增的算力，并应用阶梯计算规则。
