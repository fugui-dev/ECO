# 动态补偿算力计算实现总结

## 📊 **需求说明**

将矿机购买时的固定倍数补偿算力改为动态计算：
- **新规则**：补偿算力 = 原始算力 × 1.003^(n-1)
- **n** = 矿机创建时间到购买时间的天数
- **生效时间**：从第二天开始补偿（n ≥ 2）

## 🔧 **修改前的问题**

### **原有固定倍数逻辑**
```java
// 从系统配置获取固定倍数
BigDecimal increase = new BigDecimal(increaseSystemConfig.getValue());
BigDecimal actualComputingPower = new BigDecimal(minerProject.getComputingPower()).multiply(increase);
```

**问题**：
- 使用固定的系统配置倍数
- 不考虑矿机创建时间与购买时间的间隔
- 无法体现时间价值补偿

## ✅ **修改后的动态计算逻辑**

### **核心实现**

#### 1. 主计算逻辑
```java
// 计算动态补偿算力 - 1.003的n-1次方，n为矿机创建时间到购买时间的天数
BigDecimal actualComputingPower = calculateDynamicCompensationPower(minerProject, purchaseMinerProject.getCreateTime());

if (actualComputingPower.compareTo(new BigDecimal(minerProject.getComputingPower())) > 0) {
    // 设置补偿算力
    purchaseMinerProject.setActualComputingPower(actualComputingPower.toString());
    
    // 设置加速到期时间（第二天开始生效）
    LocalDateTime effectiveDate = LocalDateTime.now().plusDays(1);
    Long effectiveTime = effectiveDate.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
    purchaseMinerProject.setAccelerateExpireTime(effectiveTime);
} else {
    // 如果没有补偿，使用原始算力
    purchaseMinerProject.setActualComputingPower(minerProject.getComputingPower());
}
```

#### 2. 动态补偿算力计算方法
```java
private BigDecimal calculateDynamicCompensationPower(MinerProject minerProject, Long purchaseTime) {
    // 获取矿机创建时间
    Long minerCreateTime = minerProject.getCreateTime();
    if (minerCreateTime == null) {
        return new BigDecimal(minerProject.getComputingPower());
    }
    
    // 计算天数差
    long daysDifference = calculateDaysDifference(minerCreateTime, purchaseTime);
    
    // 从第二天开始补偿，即 n >= 2
    if (daysDifference < 2) {
        return new BigDecimal(minerProject.getComputingPower());
    }
    
    // 计算补偿倍数：1.003^(n-1)
    BigDecimal baseMultiplier = new BigDecimal("1.003");
    int exponent = (int) (daysDifference - 1); // n-1
    BigDecimal compensationMultiplier = baseMultiplier.pow(exponent);
    
    // 计算补偿算力
    BigDecimal originalPower = new BigDecimal(minerProject.getComputingPower());
    BigDecimal actualPower = originalPower.multiply(compensationMultiplier);
    
    return actualPower;
}
```

#### 3. 天数差计算方法
```java
private long calculateDaysDifference(Long startTime, Long endTime) {
    // 将时间戳转换为LocalDate
    LocalDate startDate = LocalDateTime.ofInstant(
        java.time.Instant.ofEpochMilli(startTime), 
        ZoneId.systemDefault()
    ).toLocalDate();
    
    LocalDate endDate = LocalDateTime.ofInstant(
        java.time.Instant.ofEpochMilli(endTime), 
        ZoneId.systemDefault()
    ).toLocalDate();
    
    // 计算天数差
    return java.time.temporal.ChronoUnit.DAYS.between(startDate, endDate);
}
```

## 📊 **计算示例**

### **补偿算力计算表**

| 天数差(n) | 补偿倍数(1.003^(n-1)) | 原始算力1000 | 实际算力 |
|-----------|----------------------|-------------|----------|
| 1天       | 1.000                | 1000        | 1000     |
| 2天       | 1.003                | 1000        | 1003     |
| 3天       | 1.006009             | 1000        | 1006.009 |
| 7天       | 1.018108             | 1000        | 1018.108 |
| 30天      | 1.094174             | 1000        | 1094.174 |
| 90天      | 1.300270             | 1000        | 1300.270 |
| 365天     | 2.997260             | 1000        | 2997.260 |

### **实际场景示例**

```
矿机项目A：
- 创建时间：2024-01-01 00:00:00
- 购买时间：2024-01-05 10:30:00
- 天数差：4天
- 补偿倍数：1.003^(4-1) = 1.003^3 = 1.009027
- 原始算力：1000
- 实际算力：1000 × 1.009027 = 1009.027

矿机项目B：
- 创建时间：2024-01-01 00:00:00
- 购买时间：2024-01-01 15:30:00
- 天数差：0天（当天购买）
- 补偿倍数：无补偿
- 原始算力：1000
- 实际算力：1000（无补偿）
```

## 🔄 **修改前后对比**

| 特性 | 修改前 | 修改后 |
|------|--------|--------|
| **计算方式** | 固定倍数 | 动态计算 1.003^(n-1) |
| **时间因素** | 不考虑 | 考虑矿机创建到购买的时间间隔 |
| **补偿规则** | 立即生效 | 从第二天开始补偿 |
| **配置依赖** | 依赖系统配置 | 无需额外配置 |
| **计算精度** | 固定 | 基于实际天数差 |

## 🚀 **核心优势**

1. **时间价值体现**：越晚购买，补偿越多，体现时间价值
2. **动态调整**：根据实际时间间隔自动计算补偿
3. **精确计算**：使用BigDecimal确保计算精度
4. **日志记录**：详细记录计算过程，便于调试
5. **异常处理**：计算失败时回退到原始算力

## 📝 **技术细节**

### **幂运算实现**
```java
// 使用BigDecimal.pow()进行精确的幂运算
BigDecimal baseMultiplier = new BigDecimal("1.003");
int exponent = (int) (daysDifference - 1);
BigDecimal compensationMultiplier = baseMultiplier.pow(exponent);
```

### **时间计算**
```java
// 使用ChronoUnit.DAYS精确计算天数差
return java.time.temporal.ChronoUnit.DAYS.between(startDate, endDate);
```

### **日志记录**
```java
log.info("矿机{}动态补偿计算: 创建时间={}, 购买时间={}, 天数差={}, 补偿倍数={}, 原始算力={}, 实际算力={}", 
        minerProject.getId(), 
        new java.util.Date(minerCreateTime), 
        new java.util.Date(purchaseTime), 
        daysDifference, 
        compensationMultiplier, 
        originalPower, 
        actualPower);
```

## ✅ **验证要点**

1. **当天购买**：无补偿，使用原始算力
2. **第二天购买**：补偿倍数 = 1.003
3. **长期购买**：补偿倍数按指数增长
4. **异常处理**：矿机创建时间为空时使用原始算力
5. **精度保证**：使用BigDecimal避免浮点数精度问题

## 🎯 **业务影响**

- **用户激励**：鼓励用户尽早购买矿机
- **时间价值**：体现矿机项目的时间价值
- **公平性**：根据实际等待时间给予相应补偿
- **可扩展性**：补偿规则可根据业务需求调整

修改完成！现在矿机购买时的补偿算力将根据矿机创建时间到购买时间的天数差动态计算，使用1.003的n-1次方公式。
