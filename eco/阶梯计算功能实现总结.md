# 阶梯计算功能实现总结

## 概述
根据用户需求，在计算小区算力和新增算力时添加了阶梯计算功能，参考了 `RecommendStatisticsLogServiceImpl` 中的 `computingPower` 方法实现。

## 主要修改

### 1. ComputingPowerService 接口扩展
- 添加了支持阶梯计算的方法重载：
  - `calculateUserRecommendPower(String walletAddress, String dayTime, Map<Integer, BigDecimal> levelRateMap, Boolean isLevel)`
  - `calculateUserMinPower(String walletAddress, String dayTime, Map<Integer, BigDecimal> levelRateMap, Boolean isLevel)`
  - `calculateUserNewPower(String walletAddress, String dayTime, Map<Integer, BigDecimal> levelRateMap, Boolean isLevel)`

### 2. ComputingPowerServiceImpl 实现类增强
- 添加了 `RewardLevelConfigMapper` 依赖，用于获取层级配置
- 实现了新的阶梯计算方法：
  - `calculateUserRecommendPower` - 支持阶梯计算的推荐算力计算
  - `calculateUserMinPower` - 支持阶梯计算的小区算力计算
  - `calculateUserNewPower` - 支持阶梯计算的新增算力计算
  - `calculateSubordinatePowerWithLevel` - 递归计算下级算力，支持阶梯计算
  - `getLevelRateMap` - 获取层级费率映射

### 3. ComputingPowerServiceImplV2 缓存服务更新
- 添加了阶梯计算方法的缓存支持
- 确保阶梯计算结果也能被正确缓存和获取

### 4. RecommendStatisticsLogServiceImpl 集成
- 添加了 `ComputingPowerServiceImplV2` 依赖
- 修改了 `computingPower` 方法，使用新的阶梯计算服务
- 替换了原有的 `calculateSubordinates` 调用，改为使用 `computingPowerServiceV2` 的方法

## 阶梯计算逻辑

### 层级费率应用
- 通过 `RewardLevelConfig` 表获取各层级的奖励比例
- 在计算下级算力时，根据层级差应用相应的费率
- 层级差计算：`relativeLevel = subordinateLevel - parentLevel`
  - 例如：父级是3级，下级是4级，则层级差为1（下级比父级低1级）
- 支持按层级计算开关 (`isLevel` 参数)

### 算力计算流程
1. **小区算力计算**：
   - 计算所有直推用户的总算力
   - 找到最大算力的用户
   - 计算除最大算力外的其他直推算力总和
   - 应用阶梯计算规则

2. **新增算力计算**：
   - 查询当日新增的矿机
   - 根据当前用户相对于推荐人的层级差应用相应的费率
   - 层级差计算：`relativeLevel = userLevel - recommenderLevel`
   - 支持阶梯计算和普通计算两种模式

3. **推荐算力计算**：
   - 递归计算所有下级算力
   - **不需要阶梯计算**，直接累加所有下级算力
   - 支持缓存机制

## 使用方式

### 基本调用
```java
// 获取层级费率映射
Map<Integer, BigDecimal> levelRateMap = getLevelRateMap();

// 计算小区算力（阶梯计算）
SingleResponse<BigDecimal> minPowerResponse = computingPowerServiceV2.calculateUserMinPower(
    walletAddress, 
    dayTime, 
    levelRateMap, 
    true  // 启用阶梯计算
);

// 计算新增算力（阶梯计算）
SingleResponse<BigDecimal> newPowerResponse = computingPowerServiceV2.calculateUserNewPower(
    walletAddress, 
    dayTime, 
    levelRateMap, 
    true  // 启用阶梯计算
);
```

### 在推荐统计中使用
```java
// 在 RecommendStatisticsLogServiceImpl.computingPower 方法中
SingleResponse<BigDecimal> computedPowerResponse = computingPowerServiceV2.calculateUserMinPower(
    recommendStatisticsLog.getWalletAddress(),
    dayTime,
    levelRateMap,
    isLevel
);
```

## 配置说明

### 层级配置表 (reward_level_config)
- `level`: 层级
- `reward_rate`: 奖励比例（字符串格式，如 "0.1" 表示 10%）

### 参数说明
- `levelRateMap`: 层级费率映射，key为层级，value为费率
- `isLevel`: 是否启用阶梯计算
  - `true`: 启用阶梯计算，根据层级差应用费率
  - `false`: 不启用阶梯计算，直接累加算力

## 阶梯计算示例

假设有以下推荐关系：
- 用户A（第3级）推荐了用户B（第4级）
- 用户B推荐了用户C（第5级）
- 用户C推荐了用户D（第6级）

当计算用户A的推荐算力时：
1. 直接累加用户B、C、D的算力（不应用阶梯计算）
2. 推荐算力 = 用户B算力 + 用户C算力 + 用户D算力

当计算用户B的新增算力时：
- 用户B相对于推荐人A的层级差 = 4 - 3 = 1
- 应用层级1的费率到用户B的新增矿机算力上

## 注意事项

1. **缓存机制**：阶梯计算结果也会被缓存，确保性能
2. **向下兼容**：原有的计算方法仍然保留，不影响现有功能
3. **错误处理**：所有新方法都包含完整的异常处理和日志记录
4. **性能优化**：使用缓存机制避免重复计算
5. **层级差计算**：确保层级差计算正确，`relativeLevel = subordinateLevel - parentLevel`

## 测试建议

1. 测试不同层级配置下的算力计算
2. 验证阶梯计算开关的效果
3. 检查缓存机制的正确性
4. 验证与原有功能的兼容性
