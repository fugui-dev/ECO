# 算力服务迁移指南

## 概述

本指南详细说明如何将现有的 `RecommendStatisticsLogService` 替换为新的 `ComputingPowerService`。

## 修改清单

### ✅ 已完成的修改

1. **RewardConstructor.java** - 总算力计算
2. **PurchaseMinerProjectServiceImpl.java** - 矿机购买算力统计
3. **RecommendServiceImpl.java** - 推荐关系算力统计
4. **PurchaseMinerProjectScheduled.java** - 定时任务算力更新

### 🔄 需要完成的修改

#### 1. 添加依赖注入

在以下文件中添加 `ComputingPowerServiceImplV2` 的依赖注入：

**PurchaseMinerProjectServiceImpl.java:**
```java
@Resource
private ComputingPowerServiceImplV2 computingPowerServiceV2;
```

**RecommendServiceImpl.java:**
```java
@Resource
private ComputingPowerServiceImplV2 computingPowerServiceV2;
```

**PurchaseMinerProjectScheduled.java:**
```java
@Resource
private ComputingPowerServiceImplV2 computingPowerServiceV2;
```

**RewardConstructor.java:**
```java
@Resource
private ComputingPowerServiceImplV2 computingPowerServiceV2;
```

#### 2. 启用缓存清除功能

取消注释并启用缓存清除调用：

**PurchaseMinerProjectServiceImpl.java:**
```java
// 第282行，取消注释
computingPowerServiceV2.invalidateUserCache(purchaseMinerProject.getWalletAddress());
```

**RecommendServiceImpl.java:**
```java
// 第166行，取消注释
computingPowerServiceV2.invalidateUserCache(recommender.getWalletAddress());
```

**PurchaseMinerProjectScheduled.java:**
```java
// 第60行和第115行，取消注释
computingPowerServiceV2.invalidateUserCache(purchaseMinerProject.getWalletAddress());
```

**RewardConstructor.java:**
```java
// 第1354行，取消注释
computingPowerServiceV2.invalidateUserCache(purchaseMinerProject.getWalletAddress());
```

#### 3. 修改控制器层

**RecommendStatisticsLogController.java:**
```java
@Resource
private ComputingPowerService computingPowerService;

@PostMapping("/info")
SingleResponse<RecommendStatisticsLogDTO> get(@RequestBody RecommendStatisticsLogQry recommendStatisticsLogQry) {
    String dayTime = recommendStatisticsLogQry.getDayTime();
    if (dayTime == null || dayTime.trim().isEmpty()) {
        dayTime = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
    }
    
    SingleResponse<ComputingPowerDTO> response = computingPowerService.getComputingPowerInfo(
        recommendStatisticsLogQry.getWalletAddress(), dayTime);
    
    if (response.isSuccess()) {
        RecommendStatisticsLogDTO dto = convertToOldFormat(response.getData());
        return SingleResponse.of(dto);
    }
    
    return SingleResponse.buildFailure(response.getErrMessage());
}

private RecommendStatisticsLogDTO convertToOldFormat(ComputingPowerDTO newDto) {
    RecommendStatisticsLogDTO dto = new RecommendStatisticsLogDTO();
    dto.setWalletAddress(newDto.getWalletAddress());
    dto.setTotalComputingPower(newDto.getTotalPower().toString());
    dto.setTotalDirectRecommendComputingPower(newDto.getDirectRecommendPower().toString());
    dto.setTotalRecommendComputingPower(newDto.getRecommendPower().toString());
    dto.setMinComputingPower(newDto.getMinPower().toString());
    dto.setMaxComputingPower(newDto.getMaxPower().toString());
    dto.setNewComputingPower(newDto.getNewPower().toString());
    dto.setDirectRecommendCount(newDto.getDirectRecommendCount());
    return dto;
}
```

**AdminRecommendStatisticsLogController.java:**
```java
// 同样的修改
```

## 迁移策略

### 阶段1: 并行运行（推荐）
1. 保持现有 `RecommendStatisticsLogService` 继续运行
2. 在新功能中使用 `ComputingPowerService`
3. 逐步替换现有调用

### 阶段2: 逐步替换
1. 先替换查询接口（用户端）
2. 再替换内部计算逻辑
3. 最后替换统计更新逻辑

### 阶段3: 完全切换
1. 所有功能使用新服务
2. 停用 `RecommendStatisticsLogService`
3. 清理相关代码

## 性能对比

| 功能 | 原方式 | 新方式 | 优势 |
|------|--------|--------|------|
| 总算力计算 | 查询统计表 | 实时计算 | 数据一致性 |
| 用户算力查询 | 查询统计表 | 实时计算+缓存 | 准确性+性能 |
| 算力更新 | 更新统计表 | 清除缓存 | 简化逻辑 |
| 数据一致性 | 可能不同步 | 实时同步 | 高一致性 |

## 注意事项

### 1. 缓存管理
- 矿机状态变化时必须清除用户缓存
- 推荐关系变化时必须清除推荐人缓存
- 可以批量清除某日的所有缓存

### 2. 性能考虑
- 首次查询可能较慢（需要计算）
- 后续查询会使用缓存（快速）
- 建议在低峰期进行大批量操作

### 3. 数据验证
- 迁移后需要对比新旧系统的计算结果
- 建议保留一段时间的数据对比
- 发现差异时及时排查

### 4. 回滚准备
- 保留原有代码的注释版本
- 准备快速回滚方案
- 监控系统性能指标

## 测试建议

### 1. 单元测试
```java
@Test
public void testComputingPowerCalculation() {
    // 测试算力计算准确性
    BigDecimal totalPower = ComputingPowerUtil.getTotalPower("2024-01-01");
    assertThat(totalPower).isGreaterThan(BigDecimal.ZERO);
}
```

### 2. 集成测试
```java
@Test
public void testRewardCalculation() {
    // 测试奖励计算是否正常
    // 对比新旧系统的计算结果
}
```

### 3. 性能测试
- 测试大量用户时的查询性能
- 测试缓存命中率
- 测试并发访问情况

## 监控指标

1. **算力计算耗时** - 监控计算性能
2. **缓存命中率** - 监控缓存效果
3. **数据一致性** - 对比新旧系统结果
4. **错误率** - 监控异常情况

## 总结

通过以上修改，您可以：
1. 获得更准确的算力计算
2. 简化算力更新逻辑
3. 提高系统性能（通过缓存）
4. 保持数据一致性

建议按照阶段逐步迁移，确保系统稳定运行。