# 算力定义修复验证

## 📊 **修复后的正确算力定义**

### **`directRecommendPower`（直推算力）**
- **定义**：直接推荐用户的**自身算力总和**
- **不包括**：直推用户的下级算力
- **计算方式**：遍历所有直推用户，累加每个直推用户的自身算力

### **`recommendPower`（推荐算力）**
- **定义**：所有下级的**总算力总和**（直推 + 所有子级）
- **包括**：直推用户及其所有下级子级的算力
- **计算方式**：遍历所有直推用户，累加每个直推用户的总算力（自身 + 所有下级）

## 🔍 **修复前后对比**

### **修复前（错误）**
```java
// 直推算力 - 错误地计算了直推用户的总算力
for (Recommend directRecommend : directRecommends) {
    SingleResponse<BigDecimal> totalPowerResponse = calculateUserTotalPower(directRecommend.getWalletAddress(), dayTime);
    directRecommendPower = directRecommendPower.add(totalPowerResponse.getData());
}

// 推荐算力 - 错误地包含了当前用户自己的算力
BigDecimal recommendPower = calculateSubordinatePower(walletAddress, dayTime, new HashMap<>());
```

### **修复后（正确）**
```java
// 直推算力 - 只计算直推用户的自身算力
for (Recommend directRecommend : directRecommends) {
    SingleResponse<BigDecimal> selfPowerResponse = calculateUserSelfPower(directRecommend.getWalletAddress(), dayTime);
    directRecommendPower = directRecommendPower.add(selfPowerResponse.getData());
}

// 推荐算力 - 计算所有下级的总算力
for (Recommend directRecommend : directRecommends) {
    BigDecimal subordinatePower = calculateSubordinatePower(directRecommend.getWalletAddress(), dayTime, new HashMap<>());
    recommendPower = recommendPower.add(subordinatePower);
}
```

## 📊 **算力层级结构示例**

```
用户A
├── 直推B (自身算力=100)
│   ├── B的子级1 (自身=50 + 下级=100) = 150总算力
│   └── B的子级2 (自身=200 + 下级=150) = 350总算力
│       └── B的子级2的子级 (自身=150) = 150总算力
├── 直推C (自身算力=200)
│   ├── C的子级1 (自身=100 + 下级=100) = 200总算力
│   └── C的子级2 (自身=100) = 100总算力
└── 直推D (自身算力=300)
    ├── D的子级1 (自身=200 + 下级=100) = 300总算力
    └── D的子级2 (自身=100) = 100总算力

用户A的算力计算：
- 自身算力 = 用户A的矿机算力
- 直推算力 = 100 + 200 + 300 = 600（只计算直推用户的自身算力）
- 推荐算力 = (100+150+350) + (200+200+100) + (300+300+100) = 600 + 500 + 700 = 1800（直推+所有子级）
- 总算力 = 自身算力 + 推荐算力
```

## ✅ **修复验证**

### **直推算力验证**
- ✅ 只计算直推用户的自身算力
- ✅ 不包括直推用户的下级算力
- ✅ 使用 `calculateUserSelfPower()` 方法

### **推荐算力验证**
- ✅ 计算所有下级的总算力
- ✅ 包括直推用户及其所有子级
- ✅ 使用 `calculateSubordinatePower()` 方法递归计算
- ✅ 不包含当前用户自己的算力

## 🎯 **总结**

修复后的算力计算逻辑完全符合业务需求：
- **直推算力** = 直接推荐用户的自身算力总和
- **推荐算力** = 直推算力 + 所有子级的算力
- **总算力** = 自身算力 + 推荐算力