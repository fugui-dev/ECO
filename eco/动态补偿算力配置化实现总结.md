# 动态补偿算力配置化实现总结

## 📊 **需求更新**

根据用户反馈，修改补偿算力计算逻辑：
1. **倍数配置**：从数据库 `INCREASE_MULTIPLIER` 配置获取（而不是硬编码1.003）
2. **有效期配置**：从数据库 `EFFECTIVE_DAY` 配置获取
3. **生效时间**：从购买时就开始补偿（而不是从第二天开始）

## 🔧 **修改内容**

### **1. 主计算逻辑更新**

```java
// 计算动态补偿算力 - 从数据库获取倍数配置，使用baseMultiplier^(n-1)公式
BigDecimal actualComputingPower = calculateDynamicCompensationPower(minerProject, purchaseMinerProject.getCreateTime());

if (actualComputingPower.compareTo(new BigDecimal(minerProject.getComputingPower())) > 0) {
    // 设置补偿算力
    purchaseMinerProject.setActualComputingPower(actualComputingPower.toString());
    
    // 设置加速到期时间（从购买时开始，有效期从配置获取）
    Long effectiveTime = calculateEffectiveTime();
    purchaseMinerProject.setAccelerateExpireTime(effectiveTime);
} else {
    // 如果没有补偿，使用原始算力
    purchaseMinerProject.setActualComputingPower(minerProject.getComputingPower());
}
```

### **2. 动态补偿算力计算方法**

```java
private BigDecimal calculateDynamicCompensationPower(MinerProject minerProject, Long purchaseTime) {
    // 从数据库获取倍数配置
    LambdaQueryWrapper<SystemConfig> increaseQueryWrapper = new LambdaQueryWrapper<>();
    increaseQueryWrapper.eq(SystemConfig::getName, SystemConfigEnum.INCREASE_MULTIPLIER.getCode());
    SystemConfig increaseSystemConfig = systemConfigMapper.selectOne(increaseQueryWrapper);
    
    if (increaseSystemConfig == null || increaseSystemConfig.getValue() == null) {
        return new BigDecimal(minerProject.getComputingPower());
    }
    
    BigDecimal baseMultiplier = new BigDecimal(increaseSystemConfig.getValue());
    
    // 计算天数差
    long daysDifference = calculateDaysDifference(minerCreateTime, purchaseTime);
    
    // 从购买时开始补偿，即 n >= 1
    if (daysDifference < 1) {
        return new BigDecimal(minerProject.getComputingPower());
    }
    
    // 计算补偿倍数：baseMultiplier^(n-1)
    int exponent = (int) (daysDifference - 1); // n-1
    BigDecimal compensationMultiplier = baseMultiplier.pow(exponent);
    
    // 计算补偿算力
    BigDecimal originalPower = new BigDecimal(minerProject.getComputingPower());
    BigDecimal actualPower = originalPower.multiply(compensationMultiplier);
    
    return actualPower;
}
```

### **3. 有效期计算方法**

```java
private Long calculateEffectiveTime() {
    // 从数据库获取有效期配置
    LambdaQueryWrapper<SystemConfig> effectiveQueryWrapper = new LambdaQueryWrapper<>();
    effectiveQueryWrapper.eq(SystemConfig::getName, SystemConfigEnum.EFFECTIVE_DAY.getCode());
    SystemConfig effectiveSystemConfig = systemConfigMapper.selectOne(effectiveQueryWrapper);
    
    if (effectiveSystemConfig == null || effectiveSystemConfig.getValue() == null) {
        // 如果没有配置，默认1天有效期
        LocalDateTime effectiveDate = LocalDateTime.now().plusDays(1);
        return effectiveDate.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
    }
    
    // 从购买时开始，加上配置的有效天数
    long effectiveDays = Long.parseLong(effectiveSystemConfig.getValue());
    LocalDateTime effectiveDate = LocalDateTime.now().plusDays(effectiveDays);
    return effectiveDate.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
}
```

## 📊 **配置说明**

### **数据库配置表 (system_config)**

| 配置名称 | 配置值 | 说明 | 示例 |
|----------|--------|------|------|
| `INCREASE_MULTIPLIER` | 基础倍数 | 补偿算力的基础倍数 | `1.003` |
| `EFFECTIVE_DAY` | 有效天数 | 补偿算力的有效天数 | `30` |

### **计算示例**

假设配置：
- `INCREASE_MULTIPLIER` = `1.003`
- `EFFECTIVE_DAY` = `30`

矿机项目A：
- 创建时间：2024-01-01 00:00:00
- 购买时间：2024-01-05 10:30:00
- 天数差：4天
- 补偿倍数：1.003^(4-1) = 1.003^3 = 1.009027
- 原始算力：1000
- 实际算力：1000 × 1.009027 = 1009.027
- 有效期：购买时开始，30天后到期

## 🔄 **修改前后对比**

| 特性 | 修改前 | 修改后 |
|------|--------|--------|
| **倍数来源** | 硬编码1.003 | 数据库配置 `INCREASE_MULTIPLIER` |
| **有效期来源** | 硬编码1天 | 数据库配置 `EFFECTIVE_DAY` |
| **生效时间** | 第二天开始 | 购买时开始 |
| **补偿条件** | n >= 2 | n >= 1 |
| **配置灵活性** | 无 | 完全可配置 |

## 📊 **补偿算力计算表**

假设 `INCREASE_MULTIPLIER` = `1.003`：

| 天数差(n) | 补偿倍数(1.003^(n-1)) | 原始算力1000 | 实际算力 |
|-----------|----------------------|-------------|----------|
| 0天       | 1.000                | 1000        | 1000     |
| 1天       | 1.003                | 1000        | 1003     |
| 2天       | 1.006009             | 1000        | 1006.009 |
| 7天       | 1.018108             | 1000        | 1018.108 |
| 30天      | 1.094174             | 1000        | 1094.174 |
| 90天      | 1.300270             | 1000        | 1300.270 |
| 365天     | 2.997260             | 1000        | 2997.260 |

## ✅ **核心优势**

1. **配置化**：倍数和有效期完全可配置，无需修改代码
2. **灵活性**：可以根据业务需求调整补偿策略
3. **即时生效**：从购买时就开始补偿，用户体验更好
4. **精确计算**：使用BigDecimal确保计算精度
5. **异常处理**：配置缺失时有合理的默认值

## 🚀 **使用方式**

### **配置设置**
```sql
-- 设置补偿倍数
INSERT INTO system_config (name, value, description) 
VALUES ('INCREASE_MULTIPLIER', '1.003', '矿机增加倍数');

-- 设置有效期
INSERT INTO system_config (name, value, description) 
VALUES ('EFFECTIVE_DAY', '30', '增加倍数有效天数');
```

### **业务逻辑**
- 矿机购买时自动计算动态补偿算力
- 补偿算力立即生效
- 有效期从购买时开始计算
- 到期后恢复原始算力

## 📝 **技术细节**

### **配置获取**
```java
// 获取倍数配置
SystemConfig increaseSystemConfig = systemConfigMapper.selectOne(
    new LambdaQueryWrapper<SystemConfig>()
        .eq(SystemConfig::getName, SystemConfigEnum.INCREASE_MULTIPLIER.getCode())
);

// 获取有效期配置
SystemConfig effectiveSystemConfig = systemConfigMapper.selectOne(
    new LambdaQueryWrapper<SystemConfig>()
        .eq(SystemConfig::getName, SystemConfigEnum.EFFECTIVE_DAY.getCode())
);
```

### **幂运算实现**
```java
// 使用BigDecimal.pow()进行精确的幂运算
BigDecimal baseMultiplier = new BigDecimal(increaseSystemConfig.getValue());
int exponent = (int) (daysDifference - 1);
BigDecimal compensationMultiplier = baseMultiplier.pow(exponent);
```

### **时间计算**
```java
// 从购买时开始计算有效期
LocalDateTime effectiveDate = LocalDateTime.now().plusDays(effectiveDays);
Long effectiveTime = effectiveDate.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
```

## 🎯 **业务影响**

- **用户体验**：补偿算力立即生效，用户感受更好
- **配置管理**：管理员可以通过数据库配置调整补偿策略
- **业务灵活性**：可以根据市场情况调整倍数和有效期
- **系统稳定性**：配置缺失时有合理的默认行为

修改完成！现在补偿算力计算完全基于数据库配置，从购买时就开始生效，提供了更好的灵活性和用户体验。
